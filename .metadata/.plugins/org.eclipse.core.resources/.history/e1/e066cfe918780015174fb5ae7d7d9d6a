package learning.ks8;

import java.util.HashMap;
import java.util.Scanner;
import java.util.Set;

// ^*a+bc/-def
// 2 2 3 10 4 3
public class MainTest {
	private static final Scanner cin = new Scanner(System.in);
	private static final HashMap<Character, Integer> priority = new HashMap<>();
	private static final HashMap<Character, Integer> map = new HashMap<>();

	public static void main(String[] args) {
		init();
		int n;
		while (true) {
			System.out.println("1:计算单个表达式");
			System.out.println("2:合并");
			System.out.println("3:退出");
			n = cin.nextInt();
			switch (n) {
			case 1:
				onlyOne();
				break;
			case 2:
				bing();
				break;
			default:
				return;
			}
		}
	}
	private static void bing(){
		System.out.println("输入第一个前缀表达式：");
		String str1=cin.next();
		Tree root1=CreateTree(str1);
		if (root1 == null) {
			System.out.println("表达式有误！");
			System.exit(0);
		}
//		addKuo(root1);
		System.out.println("输入第一个前缀表达式：");
		String str2=cin.next();
		Tree root2=CreateTree(str1);
		if (root2 == null) {
			System.out.println("表达式有误！");
			System.exit(0);
		}
//		addKuo(root2);
		System.out.println("输入表达式之间的运算符：");
		String ss=cin.next();
		char fu=ss.charAt(0);
		Tree root=new Tree();
		root.setLeft(root1);
		root.setRight(root2);
		root1.setParent(root);
		root2.setParent(root);
		addKuo(root);
		
	}
	
	private static void init() {
		priority.put('+', 1);
		priority.put('-', 1);
		priority.put('*', 2);
		priority.put('/', 2);
		priority.put('^', 3);
	}

	private static void onlyOne() {
		System.out.println("输入前缀表达式：");
		String str = cin.next();
		Tree root = CreateTree(str);
		if (root == null) {
			System.out.println("表达式有误！");
			System.exit(0);
		}
		addKuo(root);
		System.out.println("表达式为：");
		bianLi(root);
		System.out.println();
		int result=getResult(root);
		System.out.println(result);
	}

	private static int getResult(Tree root) {
		if (root == null)
			return 0;
		int left = 0;
		int right = 0;
		boolean flag = false;
		if (root.getLeft() != null) {
			flag = true;
			left = getResult(root.getLeft());
		} else {
			left = 0;
		}
		if (root.getRight() != null) {
			flag = true;
			right = getResult(root.getRight());
		} else {
			right = 0;
		}
		if (flag == false)
			return map.get(root.getData());
		switch (root.getData()) {
		case '+':
			return left + right;
		case '-':
			return left - right;
		case '*':
			return left * right;
		case '/':
			return left / right;
		case '^':
			return (int) Math.pow(left, right);
		}
		return left + right;
	}

	private static void addKuo(Tree root) {
		if (map.containsKey(root.getData()))
			return;
		getPri(root);

	}

	private static int getPri(Tree root) {
		if (map.containsKey(root.getData())) {
			return 4;
		}
		int k = priority.get(root.getData());
		int pri1 = 0;
		int pri2 = 0;
		if (root.getLeft() != null) {
			pri1 = getPri(root.getLeft());
		}
		Tree left = root.getLeft();
		if (pri1 != 4 && (pri1 < k)) {
			while (!map.containsKey(left.getData())) {
				left = left.getLeft();
			}
			left.setlNum(left.getlNum() + 1);
			left = root.getLeft();
			while (!map.containsKey(left.getData())) {
				left = left.getRight();
			}
			left.setrNum(left.getrNum() + 1);
		}
		if (root.getRight() != null) {
			pri2 = getPri(root.getRight());
		}
		Tree right = root.getRight();
		if (pri2 != 4 && (pri2 <= k)) {
			while (!map.containsKey(right.getData())) {
				right = right.getLeft();
			}
			right.setlNum(right.getlNum() + 1);
			right = root.getRight();
			while (!map.containsKey(right.getData())) {
				right = right.getRight();
			}
			right.setrNum(right.getrNum() + 1);
		}
		return priority.get(root.getData());
	}

	private static void bianLi(Tree root) {
		if (root == null)
			return;
		if (root.getLeft() != null) {
			bianLi(root.getLeft());
		}
		if (root.getlNum() != 0) {
			for (int i = 0; i < root.getlNum(); i++)
				System.out.print('(');
		}
		System.out.print(root.getData());
		if (root.getrNum() != 0) {
			for (int i = 0; i < root.getrNum(); i++)
				System.out.print(')');
		}
		if (root.getRight() != null) {
			bianLi(root.getRight());
		}
	}

	private static Tree CreateTree(String str) {
		for (int i = 0; i < str.length(); i++) {
			if (priority.containsKey(str.charAt(i)) == false) {
				if (map.containsKey(str.charAt(i)) == false) {
					map.put(str.charAt(i), 0);
				}
			}
		}
		 Set<Character> kSet = map.keySet();
		 java.util.Iterator<Character> it = kSet.iterator();
		 while (it.hasNext()) {
		 char ch = it.next();
		 System.out.println("输入" + ch + "的值：");
		 int k = cin.nextInt();
		 map.replace(ch, k);
		 }
		Tree root = new Tree();
		root.setData(str.charAt(0));
		int d = 1;
		while (d < str.length()) {
			Tree temp = new Tree();
			temp.setData(str.charAt(d));
			if (root == null)
				return null;
			while (root != null && map.containsKey(root.getData())) {
				root = root.getParent();
			}
			while (root != null && root.getLeft() != null && root.getRight() != null) {
				root = root.getParent();
			}
			if (root.getLeft() == null) {
				root.setLeft(temp);
				temp.setParent(root);
				root = root.getLeft();
				d++;
				continue;
			}
			if (root.getRight() == null) {
				root.setRight(temp);
				temp.setParent(root);
				root = root.getRight();
				d++;
				continue;
			}
		}
		while (root.getParent() != null) {
			root = root.getParent();
		}
		return root;
	}
}
